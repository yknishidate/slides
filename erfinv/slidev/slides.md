---
theme: seriph
background: https://cover.sli.dev
title: Approximating the erfinv function
info: |
  ## erfinv 関数の近似
  Mike Giles
transition: slide-left
mdc: true
---

# erfinv 関数の近似

<div class="opacity-80">
Mike Giles
</div>

<div class="abs-br m-6 flex gap-2">
  <div class="text-sm opacity-50">
  Based on "Approximating the erfinv function"
  </div>
</div>

<!--
逆誤差関数 erfinv は数学ライブラリの標準的な構成要素であり、特に一様乱数を正規乱数へ変換する統計的応用で有用である。
本プレゼンテーションでは、GPU 実行におけるワープ・ダイバージェンス（warp divergence）を低減し、効率的に計算する手法を紹介します。
-->

---

# はじめに：逆誤差関数とは

<div class="grid grid-cols-2 gap-8">
<div>

- **基本関数**: $\cos, \sin, e^x$ 等と同様に、標準的な数学ライブラリ (MKL, ACML, CUDA) に含まれる。
- **定義**: 誤差関数 $\mathrm{erf}(x)$ の逆関数。

$$
\mathrm{erf}(x)=\frac{2}{\sqrt{\pi}}\int_{0}^{x} e^{-t^{2}} dt
$$

</div>
<div>

### 主な用途：計算ファイナンス

- **モンテカルロ・シミュレーション**:
    - 一様乱数 $x \in (0,1)$ を正規乱数 $y$ に変換。
- **正規分布の累積分布関数 (CDF)**:
    - $\Phi(x)$ と $\mathrm{erf}$ は密接に関連。

$$
\Phi^{-1}(x)=\sqrt{2} \mathrm{erfinv}(2x-1)
$$

</div>
</div>

<!--
erfinv は、特に計算ファイナンスの分野で重要です。
一様乱数を正規乱数に変換する「逆関数法」で使用されます。
Box-Muller法やZiggurat法もありますが、準乱数（QMC）を使用する場合、低偏差列の特性を保つためにこの逆関数法が好まれます。
-->

---

# 既存手法：CPU 向け実装

<div class="grid grid-cols-2 gap-8">
<div>

### 従来のアルゴリズム
- **多項式/有理式近似**を使用（例: Blair et al. [BEJ76]）。
- **条件分岐**で計算コストを最適化。
    - **領域A ($|x|>0.9375$)**: 高コスト（$\log, \sqrt{}$）
    - **領域B ($|x|>0.75$)**: 中コスト
    - **領域C (その他)**: 低コスト（確率 0.75）

</div>
<div>

### 疑似コード (Table 1)

```cpp
a = |x|
if a > 0.9375 then
    t = sqrt(log(a))
    y = p1(t) / p2(t)
else if a > 0.75 then
    y = p3(a) / p4(a)
else
    y = p5(a) / p6(a)
end if
if x < 0 then
    y = -y
end if
```

</div>
</div>

<!--
CPUでは条件分岐は有効な最適化です。
Blairらのアルゴリズムでは、最も軽い分岐（領域C）に入る確率は75%あり、全体的な平均コストを下げることができます。
-->

---

# GPU での問題点：ワープ・ダイバージェンス

<div class="grid grid-cols-2 gap-8">
<div>

### SIMT アーキテクチャの制約
- GPU は 32 スレッド (ワープ) が同じ命令を実行。
- **どこか1つでも**重い分岐に入ると、全スレッドが待たされる。

</div>
<div>

<v-click>

### 確率の罠
- 1スレッドが「低コスト領域」を通る確率:
    - $P(\text{Low Cost}) = 0.75$
- 32スレッド**全員**が「低コスト領域」を通る確率:
    - $0.75^{32} \approx 0.0001 (0.01\%)$

→ ほぼ全ワープで「高コストな分岐」が実行される

</v-click>

</div>
</div>

<!--
CPUでは条件分岐は有効な最適化ですが、SIMTアーキテクチャのGPUでは逆効果になりえます。
Blairらのアルゴリズムでは、最も軽い分岐に入る確率は75%ですが、
32スレッド全員がそこに入る確率は0.01%しかありません。
結果として、ほとんどのワープで「全ての分岐」が実行されることになり、最悪ケースのコストがかかってしまいます。
-->

---

# 提案手法：アプローチ

<div class="text-xl">

**条件分岐を減らし、ワープ内の挙動を揃える**

</div>

<br>

- **単精度 (SP)**: 2つの領域（中心・尾部）に簡略化。
- **倍精度 (DP)**: 精度要求のため3つの領域を使用するが、構造は単純化。

$$
\mathrm{erfinvSP}(x)=
\begin{cases}
x p_1(w), & w\le w_1 \quad \text{（中心領域：高確率）}\\
x p_2(s), & w_1 < w \quad \text{（尾部領域：稀）}
\end{cases}
$$

ここで $w=-\log(1-x^2)$、$s=\sqrt{w}$

<!--
提案手法の核心は、分岐の数を減らし、かつ「ほとんどのスレッドが同じ分岐（中心領域）を通る」ように境界 $w_1$ を設定することです。
これにより、ワープ・ダイバージェンスの発生確率そのものを制御可能にします。
-->


---
layout: center
---

![fig1](/images/fig1.png){width="50%" class="mx-auto"}

図1 $\mathrm{erfinv}(x)/x$ を $w$ および $s\equiv\sqrt{w}$ に対してプロット

---

# 単精度 (SP) 近似の構成

### 近似関数の設計指針
1.  **$x \approx 0$ (中心)**: $\mathrm{erfinv}$ は奇関数 $\to x p_1(w)$ の形 ($p_1$ は $w$ の多項式)。
2.  **$x \approx \pm 1$ (尾部)**: $\mathrm{erfinv} \approx \pm \sqrt{w} \to x p_2(\sqrt{w})$ の形。


### パラメータの選択（トレードオフ）

| $w_1$ (閾値) | $p_1$ 次数 | 尾部確率 (1スレッド) | ダイバージェンス確率 (32スレッド) |
| :--- | :---: | :---: | :---: |
| **5.00** | 8 | 0.3% | ~10% |
| **6.25** | **9** | **0.1%** | **~3%** |
| 16.00 | 14 | 0% | 0% |

<!--
表に示すように、境界 $w_1$ をどこに置くかでトレードオフが生じます。
$w_1=5.00$ なら多項式の次数は低くて済みますが、ダイバージェンス確率は10%です。
$w_1=6.25$ に上げると、次数は1つ増えますが、ダイバージェンス確率は3%まで下がります。
著者はこのバランスからアプローチを選択しています。
-->

---

# 倍精度 (DP) への拡張

倍精度では広い範囲 ($w \approx 36$) をカバーする必要があります。

$$
\mathrm{erfinvDP}(x)=
\begin{cases}
x p_1(w), & w\le w_1 \\
x p_2(s), & w_1<w\le w_2 \\
x p_3(s), & w_2<w
\end{cases}
$$

### パラメータ設定例

| $w_1$ | $w_2$ | $p_1$ 次数 | $p_2$ 次数 | $p_3$ 次数 |
| :--- | :--- | :---: | :---: | :---: |
| 6.25 | 16.0 | 22 | 18 | 16 |
| 6.25 | 36.0 | 22 | 26 | n/a |

<!--
倍精度の場合も同様の戦略ですが、より高い精度($10^{-16}$)が求められるため、尾部領域を分割するか、次数を上げる必要があります。
解析にはMATLABの可変精度演算（Symbolic Toolbox）を使用して、倍精度以上の精度で係数を決定しました。
-->

---

# 精度と誤差解析

浮動小数点演算における主な誤差要因：

1.  **入力変換**: $(1-x)(1+x)$
2.  **対数計算**: $\log$
3.  **多項式評価**: ホーナー法等

$$
\text{全体誤差} \approx \underbrace{(\varepsilon_1+\varepsilon_2)\frac{p_1'(w)}{p_1(w)}}_{\text{引数誤差の増幅}} + \underbrace{\varepsilon_3}_{\text{関数近似}} + \underbrace{\varepsilon_4}_{\text{演算誤差}}
$$

<div class="grid grid-cols-2 gap-4 mt-4 bg-gray-100 p-4 rounded dark:bg-gray-800">
<div>

**単精度 (SP)**
- 推定最大誤差: **4 ulp**
- 実測最大誤差: $7 \times 10^{-7}$
- **既存実装より高精度**

</div>
<div>

**倍精度 (DP)**
- 推定最大誤差: **3 ulp**
- 実測差分: $2 \times 10^{-15}$
- 既存実装と同等

</div>
</div>

<!--
解析の結果、単精度では最大 4 ulp (units in last place)、倍精度では 3 ulp 程度の誤差に収まることが示されました。
実際の実装でも、既存のCUDAライブラリと比較して単精度ではむしろ精度が向上しており、倍精度でも遜色ない結果が得られています。
-->

---

# 性能評価 (ベンチマーク)

100M 個の要素に対する計算時間 (ms) の比較 (C2050 GPU)

| テスト条件 | SP (旧) | SP (新) | DP (旧) | DP (新) |
| :--- | :---: | :---: | :---: | :---: |
| **Uniform (ランダム入力)** | 31 | **10** <span class="text-green-500 text-sm">(-67%)</span> | 114 | **49** <span class="text-green-500 text-sm">(-57%)</span> |
| **Constant (一定入力)** | 11 | **9** | 30 | 48 <span class="text-red-500 text-sm">(+60%)</span> |

- **Uniform**: ランダムな入力（モンテカルロ法など）で **約3倍** 高速化。
- **Constant**: 全スレッドが同じ値を計算する場合。
    - SP: 同等。
    - DP: 常に $\log$ を計算するオーバーヘッドにより遅くなる場合がある。

<!--
結果は劇的です。
ランダムな入力（Uniform）の場合、従来のダイバージェンスの影響を排除できたため、単精度・倍精度ともに大幅な高速化（約3倍）を達成しました。
一方、入力が一定（Constant）の場合、分岐予測が効く従来法に対し、常に重い計算を行う新手法は（特に倍精度で）不利になる場合があります。
しかし、主な用途であるモンテカルロ・シミュレーションではUniformな入力が一般的であるため、この特性は非常に有利です。
-->

---

# 実装コード例 (CUDA)

```cpp {all|4-5|6-17|18-28}
__inline__ __device__ float MBG_erfinv(float x)
{
    float w, p;
    // 重い計算(log)を全員が実行（ダイバージェンス回避）
    w = - __logf((1.0f-x)*(1.0f+x));
    
    if ( w < 5.000000f ) {
        // 中心領域（97%以上の確率でここを通る）
        w = w - 2.500000f;
        p = 2.81022636e-08f;
        p = 3.43273939e-07f + p*w;
        // ... (多項式評価) ...
        p = 1.50140941f + p*w;
    }
    else {
        // 尾部領域（3%未満）
        w = sqrtf(w) - 3.000000f;
        p = -0.000200214257f;
        p = 0.000100950558f + p*w;
        // ... (多項式評価) ...
        p = 2.83297682f + p*w;
    }
    return p*x;
}
```

<!--
実際のコードは非常にシンプルです。
最初に `logf` を計算していますが、これは条件分岐の外にあるため、全スレッドが同期して実行します。
その後の `if` 分岐で多項式評価を行いますが、確率的にほぼ全ての確率で `if` の中（中心領域）が実行されるため、ワープ内の待機時間は最小限になります。
-->

---

# 結論

<div class="p-6 bg-blue-50 rounded dark:bg-blue-900 mb-6">

**GPU の特性（SIMT）に合わせたアルゴリズム再設計により、<br>従来法に比べ大幅な高速化を実現可能。**

</div>

### ポイント
- **ワープ・ダイバージェンスの回避**: CPU向けの「平均コスト最適化」から GPU向けの「最悪ケース最適化」へ。
- **性能**: ランダム入力に対しては **最大3倍** 高速。
- **トレードオフ**: 一定入力に対しては遅くなる可能性があるが、主用途（乱数生成）では問題になりにくい。

### 応用
- この「主要な分岐を1つに絞る」アプローチは、他の特殊関数の近似にも応用可能です。

<!--
本研究は、単に erfinv を高速化しただけでなく、GPUプログラミングにおけるアルゴリズム設計の重要な教訓を示しています。
CPU向けに最適化された「平均的に速い」コードが、GPUでは「最悪ケース」の性能を引き出してしまう可能性があること。
そして、処理を均質化することで、GPUの並列性能を最大限に引き出せることです。
-->
