海洋スペクトル（ocean wave spectrum）は、**実際の海に存在する“さまざまな波（周波数・方向）のエネルギー分布”を統計的にモデル化したもの**です。
リアルな海面レンダリング・シミュレーションでは欠かせない概念で、Tessendorf（2004）や本論文でも基礎として使われています。

ここでは **なぜ必要？ → どんな種類がある？ → 数学的にはどう表す？ → CGではどう使う？** の順にわかりやすく解説します。

---

# 🔷 1. 海洋スペクトルとは何か？

海面は単一の正弦波ではなく、**無数の周波数・方向の波が重なってできた確率的な現象**です。

そのため、海の状態は個々の波の高さそのものより、

> 「周波数ごとにどれくらいエネルギーがあるか？」

という **エネルギー分布**のほうが安定で扱いやすい。
これを **海洋スペクトル (S(k))** と呼びます。

* 高周波（短波）ほどエネルギーが小さい
* 風速が強いと特定の波数帯が活性化する
* 統計モデルとして安定している

などの性質があります。

---

# 🔷 2. なぜスペクトルが必要なのか？

### ✔ 海面は確率的で、決定論的に高さを設定できない

リアルな海を物理法則だけで一から計算するのは非常に重い。

### ✔ スペクトルがあれば「リアルな波の分布」を1ステップで生成できる

実際、Tessendorf の海洋シェーダでは、

[
h(\mathbf{k}) = \frac{1}{\sqrt{2}}(\xi_r + i\xi_i)\sqrt{S(\mathbf{k})}
]

のように「ガウス乱数 × スペクトル」を使って初期振幅を生成します。

---

# 🔷 3. 代表的な海洋スペクトル

## ① Pierson–Moskowitz（PMスペクトル）

**風が十分長く吹き続け、完全に発達した海（fully developed sea）**を想定した古典的モデル。

[
S_{\text{PM}}(k) = \alpha g^2 k^{-3} \exp\left(-\beta \left(\frac{g}{Uk}\right)^4\right)
]

* (U)：風速
* 海洋CGの基礎としてよく使われる
* 単一方向で扱いやすいが、表現力はやや素朴

---

## ② JONSWAP スペクトル（より現実的）

PM スペクトルを拡張し、**成長途上の海**も表現できるモデル。

[
S_{\text{J}}(k) = S_{\text{PM}}(k),\gamma^{\exp\left(-\frac{(k-k_p)^2}{2\sigma^2 k_p^2}\right)}
]

* 海の実観測データに基づく
* 風速・ fetch（風が吹き続ける距離）を考慮
* PM より鋭いピークを持ち「実際の海に近い」

---

## ③ Phillips スペクトル（CGで超有名）

Tessendorf が採用した、**シンプルでCG向けのモデル**。

[
S_{\text{P}}(\mathbf{k}) = A \frac{\exp(-1/(kL)^2)}{k^4} (\hat{k}\cdot\hat{w})^2
]

* (A)：振幅
* (\hat{w})：風の方向
* 実装が簡単でリアルな見た目になる
* 高周波の発散を抑えるためのカットオフ項も含む

---

## ④ Directional Spectrum（方向スペクトル）

周波数だけでなく方向にも依存させたもの：

[
S(k,\theta) = S(k),D(\theta)
]

Directional 分布 (D(\theta)) の例：

* (\cos^s(\theta - \theta_w))
* Mitsuyasu 分布
* Donelan–Banner 分布

本論文でも、**方向スペクトルを (\psi_c(k))** として波束基底に使っています。

---

# 🔷 4. 波スペクトルの物理的意味

スペクトル (S(k)) はざっくり：

[
\text{その波数帯がどれだけ海面エネルギーを持つか}
]

を示します。

短波（大きな k）が減衰し、長波（小さな k）に比較的多くのエネルギーがあり、
風向き・風速に応じて分布が決まります。

---

# 🔷 5. CGでの利用方法（Tessendorf, 本論文含む）

### ✔ 1. スペクトルから初期波を作る

Tessendorf の海では：

[
h_0(\mathbf{k}) = \sqrt{\frac{S(\mathbf{k})}{2}}(\xi_r + i\xi_i)
]

乱数を掛けて初期フーリエ振幅を生成します。

### ✔ 2. 時間発展

分散関係で振幅を時間進行：

[
h(\mathbf{k},t) = h_0(\mathbf{k}) e^{i\omega(k)t}
]

### ✔ 3. 逆FFTで空間波形へ変換

海面高さを得る。

### ✔ 4. 本論文では波数基底 (\psi_c(k)) に使う

本論文のEulerian wavelet methodでも、

* 波束の「スペクトル形状」を決める基底
* 各波数帯 (c) について (\psi_c(k)) を割り当てる
* profile buffer の計算に直接登場

と活用されています。

つまり、**“方向・波長ごとの波エネルギー分布”**をそのまま波レットの形に落とし込むため、自然でリアルな波が出やすい。

---

# 🔷 6. まとめ：海洋スペクトルとは？

| 概念      | 説明                                              |
| ------- | ----------------------------------------------- |
| 海洋スペクトル | 周波数（波数）ごとの海面エネルギー分布                             |
| 何を解く？   | 波の“統計的性質”を表す                                    |
| なぜ必要？   | CGでリアルな海を作るには個々の波ではなく「分布」をモデル化するのが効率的           |
| 主なモデル   | PM, JONSWAP, Phillips, Directional              |
| 本論文での役割 | 波数基底 (\psi_c(k)) として利用、profile buffer の計算にも使われる |

---


以下では **profile buffer（プロファイルバッファ）** を、

* *なぜ必要なのか（動機）*
* *何を表しているのか（数学的意味）*
* *どう作るのか（計算手順）*
* *どう使うのか（描画）*
* *どんなメリットがあるか（高速化）*
  を、論文以上に分かりやすく整理して解説します。

---

# 🔷 1. なぜ profile buffer が必要なのか？

水面高さ
[
\eta(x,t) = \mathrm{Re}\int_{\theta}\int_{k} A(x,k,t),e^{i(k\cdot x - \omega(k)t + \xi(\hat{k}))},k,dk,d\theta
]
をそのまま各ピクセルで評価すると…

* **波数 (k) の積分が重い**
* **方向 (\theta) の積分も重い**
* 画面解像度 × 各点 で評価 → **とても実時間では無理**

となるからです。

つまり **そのまま積分すると計算量が爆発するため、どこかで事前計算したい**。

これを解決するのが profile buffer です。

---

# 🔷 2. profile buffer の正体：波数方向の積分を事前にまとめた 1D 波形

論文では、波数方向の積分を先にまとめて

[
\Psi_c(p,t)
= \int_0^{\infty} \psi_c(k)\cos(kp - \omega(k)t),k,dk
\tag{21}
]

という **1次元関数**にします。

ここで

* (c) … 波数バンド（(K_A) の添字）
* (\psi_c(k)) … そのバンドのスペクトル形状（例：Horvath 海洋スペクトル）
* (p = \hat{k}\cdot x + \xi(\hat{k})) … 方向ごとの位相パラメータ

つまり **波数方向の積分結果を、あらゆる座標に使える共通テーブルとして 1D 関数化したもの** が profile buffer です。

---

# 🔷 3. profile buffer が表すもの（直感的イメージ）

profile buffer (\Psi_c(p,t)) は、
**「方向 (\hat{k})、波数帯 (c) の波が、距離 (p) 離れた点へ与える“波形”」**
を表します。

これを時間ごとに計算しておけば、

* その波がどれくらいの周期で揺れるか
* その波数帯の寄与がどのような形になるか
* どの方向に進んだらどう見えるか

といった情報が 1D の「波形テーブル」として手に入ります。

---

# 🔷 4. profile buffer の作り方（PrecomputeProfileBuffers）

各フレームの最初に、次を行います：

---

### **① サンプル点 p_i を 1D 軸として並べる**

通常 N = 4096 程度
[
p_i \in [0, p_{\max}]
]

この 1D 軸が profile buffer の x 軸になります。

---

### **② 各波数バンド (c) について**

[
\Psi_c(p_i, t)
]

を積分で計算。

[
\Psi_c(p_i,t)=\int_0^\infty \psi_c(k)\cos(k p_i - \omega(k)t),k,dk
]

これは **高価な処理**。ただし、毎フレーム1回だけでよい。

---

### **③ 計算結果を GPU の 1D テクスチャに格納**

たとえば：

* texture1D Ψ[ c ][ i ]
* 波数バンド c ごとに1つの 1D テクスチャ

これが profile buffer 完成。

---

# 🔷 5. profile buffer の使用方法（WaterHeight）

水面高さ評価では、(\theta) と (c) をループしながら:

[
\eta(x,t) += A(x, k_c\hat{k}, t) \cdot \Psi_c(p, t)
]

ここで
[
p = \hat{k}\cdot x + \xi(\hat{k})
]

profile buffer は単なる **テクスチャ参照**になるため非常に軽い。

---

# 🔷 6. profile buffer のメリット

## ✔ 高価な積分を「1Dテクスチャ参照」に置き換える

本来：

* ピクセルごとに（方向 × 波数 × 積分） → 超重い

profile buffer を使うと：

* **方向 × 波数のループ → OK**
* 波数積分はすべて **1Dテクスチャ参照**に変換
* GPU に非常に向いた処理へと落とし込まれる

論文では実際に：

* 従来：**1.8 FPS**
* profile buffer 導入後：**275 FPS（233倍高速化）**

と劇的な違いが出ています。

## ✔ 見た目の高周波ディテールを保持

(\eta) の細かな揺れは profile buffer に含まれているため、

* シミュレーション（A）は粗い格子でOK
* 見た目は依然として高精細

という「うまい分業」が成立します。

---

# 🔷 7. まとめ：profile bufferとは？

**波数方向の積分を事前に（時間ごとに）1Dテクスチャ化したデータ構造。
これにより、ピクセルでの波高評価を超軽量化する仕組み。**

**役割：**

* 重い積分を前処理化
* (\eta(x,t)) の高速計算
* 実時間の波レンダリングを可能にする基盤

**本質：**

* (A(x,k,t)) ×「波形テーブル」（profile buffer）の掛け算
* → 各方向からの寄与を足して水面を再構成する

エンジニア視点では、
**「周波数積分 Rez を LUT（テクスチャ）化する高速化テクニック」**
と思ってよいです。

---


