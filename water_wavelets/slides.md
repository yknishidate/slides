---
theme: default
background: images/cover.png
title: Water Surface Wavelets
info: |
  ## Water Surface Wavelets
  IntroductionとRelated Workの要約
class: text-center
drawings:
  persist: false
transition: slide-left
mdc: true
---

# Water Surface Wavelets

STEFAN JESCHKE, TOMÁŠ SKŘIVAN, MATTHIAS MÜLLER-FISCHER,
NUTTAPONG CHENTANEZ, \
MILES MACKLIN, CHRIS WOJTAN (NVIDIA & IST Austria)\
2018, ACM Transactions on Graphics

<!--
STEFAN JESCHKE氏らによる2018年のACM Transactions on Graphicsの論文、Water Surface Waveletsの発表資料です。水面波のシミュレーションにおいて、詳細なディテールと障害物との相互作用を両立する新しい手法を提案しています。

参考資料:
- [ウェーブレット変換の総まとめ](https://shop.cqpub.co.jp/hanbai/books/30/30961/30961_9syo.pdf)
-->

---

<!-- https://www.youtube.com/watch?v=6I6BV0-BVxI -->

<Youtube id="6I6BV0-BVxI" width="100%" height="100%" />

---

# 概要: 水面シミュレーションの課題と提案

<div class="grid grid-cols-2 gap-8">

<div>

### 従来手法のジレンマ
1.  **フーリエ（スペクトル）法**
    *   $\infty$ 広大な海面、無限のディテール
    *   $\times$ **一様な波**しか扱えない（周期境界）
    *   $\times$ 移動障害物や局所的な風が苦手
2.  **PDE（差分/要素）法**
    *   $\bigcirc$ 自由な境界、障害物との干渉
    *   $\times$ **計算コスト**がディテールに比例
    *   $\times$ **CFL条件**: 速い波 $\to$ 微小な $\Delta t$
    *   $\times$ **ナイキスト限界**: 細かい波 $\to$ 密な格子

</div>

<div>

### 提案手法: Wavelet Transformation
*   **「高さ」ではなく「振幅」を計算する**
    *   変数: 局所振幅 $A(x,k,t)$
*   **なぜ振幅か？**
    *   位相/高さに比べて **空間変化が緩やか**
    *   $\Rightarrow$ **粗いグリッド** でシミュレーション可能
*   **メリット**
    *   CFL/ナイキスト制約の **大幅な緩和**
    *   物理（$A$）はGPUで高速、見た目（$\eta$）は高精細
    *   障害物対応と高解像度を両立

</div>

</div>

<!--
水面波のリアルタイムシミュレーションには長年の課題があります。大きく分けて、フーリエ変換を使うスペクトル法と、偏微分方程式を解くPDE法の二つが主流でした。

スペクトル法は広大な海面に高精細なディテールを描くのが得意ですが、その数学的性質上、全体が一様な波になってしまい、移動する船などの障害物や、場所によって変わる風などを自然に扱うのが困難です。一方、PDE法はそういった相互作用は得意ですが、細かい波を表現しようとすると格子を細かく切る必要があり、計算コストが爆発します。特に速い波を扱うための時間刻み制限（CFL条件）や、波長に対する格子解像度（ナイキスト限界）が厳しくなります。

本論文ではこのギャップを埋めるために、「オイラー型ウェーブレット変換」を提案します。これは波の「高さ」そのものを更新するのではなく、その場所にどのくらいの波があるかという「振幅」を変数として扱います。振幅は波の高さそのものよりも空間的にゆっくりとしか変化しないため、非常に粗いシミュレーション格子でも破綻なく扱えるという利点があります。これにより、物理計算は軽く済ませつつ、見た目は高精細な波を作り出すことができます。
-->

---

# 関連研究: スペクトル法 vs PDE法

<div class="grid grid-cols-2 gap-10">

<div>

### 1. スペクトル法 (FFT)
*   **仮定**: 深水、小振幅、ポテンシャル流
*   **原理**: 正弦波の重ね合わせ（解析解）
*   **Pros**:
    *   広域に**高周波ディテール**を出せる
    *   無条件安定（時間刻みが自由）
*   **Cons**:
    *   **複雑な境界**（岸壁など）が苦手
    *   **移動物体**との相互作用が困難（事前計算前提）

</div>

<div>

### 2. PDE法 (Navier-Stokes等)
*   **手法**: 有限差分法(FDM), 格子ボルツマン(LBM)
*   **原理**: 格子上で運動方程式を直接解く
*   **Pros**:
    *   **障害物相互作用**に強い
    *   環境に対する仮定が少ない
*   **Cons**:
    *   **解像度依存**: 格子サイズが見た目を縛る
    *   **重い**: 陰解法は安定だが計算コスト大
    *   数値粘性による減衰

</div>

</div>

<!--
関連研究を詳しく見ていきます。まずスペクトル法は、深水や小振幅などの仮定を置いて解析的に解く手法です。FFTを使って無数の正弦波を重ね合わせるため、どれだけズームしても詳細な波が見えるのが強みです。しかし、理論の導出過程で「境界がない（あるいは周期的）」ことを前提としているため、複雑な地形や動く障害物を入れるのが原理的に苦手です。

対してPDE法は、ナビエ・ストークス方程式などを格子状に切って数値的に解くアプローチです。こちらは物理法則をそのまま解くので、障害物の反射などを自然に扱えます。しかし、「波の形」を直接格子で表現しなければならないため、細かい波を出すには格子を極限まで細かくする必要があり、リアルタイムで大規模な海を表現するのは計算資源的に不可能です。
-->

---

# 関連研究: ハイブリッド手法 & アート制御

### 3. ハイブリッド手法 (Wave Particles / Packets)
*   **Wave Particles / Packets**:
    *   全域波を「粒子」や「波束」に分割して追跡（ラグランジュ的）
    *   障害物との相互作用が可能になる
*   **本手法 (Eulerian Wavelets)**:
    *   同じ方向性を **オイラー的（格子上の場）** で実現
    *   **利点**: 計算量が粒子数に依存せず一定、GPU実装やテクスチャ連携が容易

### 4. アートディレクション
*   **既存**: キーフレーム、ガイド力、減衰、プリミティブ合成
*   **新規性**: **「振幅 $A$」を直接制御できる**
    *   局所的に「ここだけ波を高くする」「向きを変える」が容易
    *   物理ベースの挙動をアーティストが直感的に上書き可能

<!--
これらを組み合わせようとするハイブリッドな手法も存在します。「Wave Particles」や「Wave Packets」は、波全体を小さな粒子やパケットに分解して追跡することで、局所的な相互作用を実現しました。これらはラグランジュ的、つまり粒子を追跡する手法です。本論文の手法も考え方は似ていますが、これをオイラー的、つまり固定された格子上の場として解く点が異なります。これにより、波の数が増えても計算負荷が一定に保たれ、GPUのテクスチャ機能とも親和性が高いというシステム上の利点があります。

また、波の動きを人為的に制御する「アートディレクション」の観点でも、本手法はユニークです。これまでは外力を加えたり無理やり合成したりしていましたが、本手法ではシミュレーション変数そのものが「局所的な波の強さと向き」を表しているため、アーティストが直接ブラシで波を描くように変数を上書きしても、物理シミュレーションが破綻しにくいという特徴があります。
-->

---

# 理論: 局所振幅 $A$ の導入

<div class="grid grid-cols-2 gap-8">

<div>

### なぜ変数を変えるのか

*   **高さ場 $\eta(x,t)$**:
    *   波長に合わせて高周波で振動
    *   $\to$ **密なサンプリング必須**
*   **局所振幅 $A(x,k,t)$**:
    *   「その場所にどんな波がどれくらいあるか」
    *   $\to$ **変化が緩やか**

</div>

<div>

<img src="/images/fig2.png" class="h-60 mx-auto" />

<p class="text-xs text-center opacity-75 mt-2">
A(x, y, &theta;, k) を離散化する4次元グリッド。
各空間位置 (x, y) は極座標グリッド (k, &theta;) を持ち、位置・波数・角度ごとの振幅を格納する。
</p>

</div>

</div>

<!--
理論の核心部分です。なぜ「高さ」ではなく「振幅」を変数にするのか。波の高さは空間的に激しく振動するため、それを正確に捉えるには細かいサンプリングが必要です。
一方、「波の勢い（振幅）」の分布そのものは、波自体の振動に比べて空間的にゆっくりとしか変化しません。

-->

---

# 理論: Eulerian Wavelet Transformation

### ガボール変換（窓付きフーリエ）からの導出

$$
\eta(x,t) \approx \mathrm{Re} \int A(x,k,t) e^{i(k\cdot x - \omega(k)t)} dk
$$

*   振動成分 $e^{i(...)}$ を積分カーネルに追い出し、変数 $A$ を滑らかに保つ
*   $A$ は **低周波** なので、粗い格子で表現しても情報落ちが少ない
*   $\Rightarrow$ **「見える波」の解像度が、シミュレーション格子の解像度に縛られない**

<!--
本手法ではガボール変換を用いて、激しく振動する位相成分を積分の式の方へ追い出し、シミュレーション変数 $A$ を「ゆっくり変化する振幅」として定義し直しました。
これにより、シミュレーション用の格子が粗くても、最終的に再構成される波は高精細なディテールを保つことができます。つまり、シミュレーションの解像度と、描画される波の解像度を切り離すことに成功したのです。
-->

---

# 理論: 時間発展方程式

### $A$ はどう動くか (Equation 10)
分散関係を局所線形化すると、以下の単純な移流方程式が得られる:

$$
\frac{\partial A}{\partial t} = -\underbrace{\omega'(k)}_{\text{群速度}} (\hat{k}\cdot\nabla_x) A
$$

*   **意味**: 振幅 $A$ は、方向 $\hat{k}$ に向かって、**群速度 $\omega'(k)$ で流れていくだけ**
*   波の形を変えずに、エネルギーの塊が移動していくイメージ
*   **境界条件**:
    *   領域外: $A_{\text{ambient}}$ (外洋の波)
    *   壁面: $k_{\text{reflect}}$ (鏡面反射した波数ベクトル) を参照

### 近似と議論
*   **近似精度**: $k$ 近傍での線形化だが、ガウス窓の効果で誤差は抑制される
*   **位相**: 位相そのものを粗く扱うとエイリアシングが出る $\to$ ランダム位相などで誤魔化す

<!--
では、その新しい変数 $A$ は時間とともにどう変化するのでしょうか。数式を整理していくと、驚くほど単純な「移流方程式」に帰着します。これは、ある波数の波のエネルギー（振幅）が、その波の「群速度」で空間を移動していく、ということを表しています。複雑な干渉などは積分の段階で発生するので、更新式自体は単に値を流すだけです。

境界条件もシンプルです。シミュレーション領域の外側からは「外洋の波」の値を流し込み、壁に当たったら反射ベクトルの方向へ値を流すだけです。この単純さのおかげで、GPU上で非常に高速に並列計算を行うことができます。
-->

---

# アルゴリズム詳細 1: TimeStep

**TimeStep(t)** (物理更新: 1フレーム1回)

1.  **AdvectionStep ($A$ の移流)**
    *   半ラグランジュ法 (Semi-Lagrangian) を使用
    *   無条件安定、GPU並列化に適した手法
    *   各 $(x, k)$ について、群速度で逆トレースして値を拾う
2.  **WavevectorDiffusion (拡散)**
    *   離散化の影響で振幅が細くなりすぎるのを防ぐ
    *   角拡散などを入れて、波束が自然に広がる挙動を模倣
3.  **PrecomputeProfileBuffers (波形・積分準備)**
    *   $\eta$ 再構成で使う振動項 $\Psi$ を **1Dテクスチャ** に焼く
    *   重い $\cos$ 計算などを事前計算し、描画負荷を下げる

<img src="https://upload.wikimedia.org/wikipedia/commons/b/bd/Wave_group.gif" class="w-3/5 mx-auto block object-cover mt-4" />

<!--
具体的なアルゴリズムの説明です。毎フレーム行われる「TimeStep」関数では、物理量の更新を行います。

まず「移流ステップ」で、セミラグランジュ法を使って振幅 $A$ を移動させます。自分の位置に流れ込んでくる値を上流から取ってくる手法で、非常に安定して動作します。
次に「拡散ステップ」を行います。これは、計算の都合上で波のエネルギーが不自然に細くなるのを防ぎ、波が自然に広がっていく様子を模倣するための補正処理です。
最後に、次の描画ステップのために「プロファイルバッファ」を作成します。波の再構成に必要な振動関数の積分計算は重いので、あらかじめ1次元のテクスチャとして計算して保存しておきます。
-->

---

# アルゴリズム詳細 2: WaterHeight

**WaterHeight(x,t)** (表面再構成: 頂点/ピクセル毎)

### 高速な総和計算
$$
\eta(x,t) = \sum_{\theta} \sum_{k} A(x, k_{\theta})\cdot \Psi(p, t)
$$
*   更新された $A$ (3Dテクスチャ) と $\Psi$ (1Dテクスチャ) を参照して足すだけ
*   場所 $x$ に応じてサンプリング方向を変えることで、適応的な詳細度を実現

<!--
描画時に呼ばれる「WaterHeight」関数です。ここでは、更新された振幅 $A$ と、事前計算したプロファイル $\Psi$ を掛け合わせて足し合わせることで、最終的な波の高さを求めます。
-->

---

# 実装: GPU描画パイプライン

### GPU最適化による高速化
1.  **Tessellation**: $\eta$ の凹凸に応じてメッシュを動的に分割
2.  **Vertex Shader**: WaterHeight で頂点を変位
3.  **Pixel Shader**: 解析的な微分から法線を計算し、シェーディング

### Performance
*   $\Rightarrow$ **275 fps** (GPU版) vs 1.8 fps (素朴な積分)
*   **200倍以上の高速化** (Profile Bufferの効果)

<!--
この処理は非常に軽く、GPUの頂点シェーダやピクセルシェーダの中で大量に実行可能です。本実装では、ハードウェアテッセレーションを使って、カメラに近い場所ほど細かくメッシュを分割し、遠くは粗くすることで、効率的に広大な海面を描画しています。プロファイルバッファを使った最適化により、素朴に積分するよりも200倍以上高速に動作し、複雑な波の干渉もリアルタイムで扱うことができます。
-->
